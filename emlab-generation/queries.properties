"CapacityinMW", "PowerGeneratingTechnology", "capacity= v.in().filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"PermitTriesAtLocation","Location","
return [v.name, v.permitTries];",

"PermitFailuresAtLocation","Location","
return [v.name, v.countPermitFailures];",

"AverageCompensationPayedAtLocation","Location","
return [v.name, v.totalCompensationPayed / (v.permitTries-v.countPermitFailures)];",

"AverageCompensationPayedAtLocationToLocals", "Location","
return [v.name, v.localPartyCompensation / (v.permitTries-v.countPermitFailures)];",

"CapacityinMW", "PowerGeneratingTechnology", "
return [v.name, (v.compensationPayedTechnology/ v.numberOfInvestmentsInTechnology)];",


"LocationAnalysisMW", "Location", "powerplant = v.in('SITELOCATION').filter{(it.dismantleTime > tick)}.sum{it.actualNominalCapacity}
if(powerplant == null) powerplant = 0
[v.name, powerplant]",

"PeakDemandPerZoneInMW", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.baseLoad}.baseLoad;
try{growthfactors = v.out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){    
growthfactors=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
adjustedTopSegments = topsegments*growthfactors;
return [v.outE('ZONE').inV.collect{it.name}[0], adjustedTopSegments]",

"TotalOperationalCapacityPerZoneInMW", "Zone", "t = new Table();
pp = v.in('REGION').in('LOCATION')
pp.filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.as('powerPlantCapacity').out('TECHNOLOGY').as('peakSegmentDependentAvailability').table(t){it.actualNominalCapacity}{it.peakSegmentDependentAvailability}.cap().next();
capacitySum = 0; for (row in t){capacitySum += row.getColumn('powerPlantCapacity') * row.getColumn('peakSegmentDependentAvailability')}
return [v.name, capacitySum]",

"TotalConsumptioninMWh", "DecarbonizationModel", "segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
productionsum  = 0;
for(segmentload in segmentloads){
    //productionsum += segmentload.baseLoad;
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return productionsum;",



"CO2CapinTonpA", "Government", "try{cap = v.out('CO2CAP_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){
cap = v.out('CO2CAP_TREND').timeSeries.next()[tick.toInteger()];}
return ['CO2_cap', cap]",

price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];}

"GenerationinMWh", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2};
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}
return [v.name, sum]",
    
"CO2Auction", "CO2Auction", "point=v.in('MARKET_POINT').filter{it.time==tick}
if(!point.hasNext()){price = 0} else {price=point.next().getProperty('price')}
return price",

"Avg_El_PricesinEURpMWh", "Zone", "
cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick}.toList();
[v.name, cp.sum{it.price * it.volume} / cp.sum{it.volume}];
",

"Total_DemandinMWh", "Zone", "
cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick}.toList();
[v.name, cp.sum{it.volume}];
",

"CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PowerPlantDispatchPlan']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=1}.collect();
co2Emissions = 0
for(plan in ppdps){
fuelMix=plan.out('POWERPLANT_DISPATCHPLAN').out('FUEL_MIX').collect()
singleEmission=0
    for(fuelMixElement in fuelMix){
        //fuelMixElement=fuelMix[1]
        share=fuelMixElement.share
        co2Density=fuelMixElement.out('SUBSTANCE').collect{it.co2Density}[0]*(1-plan.out('POWERPLANT_DISPATCHPLAN').out('TECHNOLOGY').collect{it.co2CaptureEffciency}[0])
        singleEmission+=share*co2Density
    }
    co2Emissions+=plan.acceptedAmount*singleEmission*plan.out('SEGMENT_DISPATCHPLAN').collect{it.lengthInHours}[0]
}
return co2Emissions",

try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];};
try{price = v.out('CO2TAX_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('CO2TAX_TREND').timeSeries.next()[tick.toInteger()];}

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

totalCMRevenue = 0;

    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCMRevenue += flow.money;
            }
    }
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue CM', totalCMRevenue])

"PriceInEURperMWh", "DecarbonizationModel", "results = []
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
for(scp in points){
    results.add(['Segment ' + scp.out('MARKET_POINT').out('ZONE').name.next() + ' ' + scp.out('SEGMENT_POINT').segmentID.next(), scp.price])
}
return results",

"ShortagesInHoursUnserved", "DecarbonizationModel", "powerplants = g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}
production= powerplants.in('POWERPLANT_DISPATCHPLAN').sum{f.determineProductionOfDispatchPlanInMWh(it, tick)};
segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']]
productionsum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return (production-productionsum)/productionsum*8760;",

    if(key in groups.keySet()){
    if(key==11){name='Capacity Market';}
    result.add([name, sum]);



"TABLE_DemandLevels", "DecarbonizationModel", "segmentLoads=ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
finalResult = [];
columnNames=['tick', 'Name', 'volume', 'market', 'segmentID', 'hours']
finalResult.add(columnNames)
for(s in segmentLoads){
market= s.in('SEGMENT_LOAD').collect{it.name}[0]
    try{growthfactor = s.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=s.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
segmentID=s.out('SEGMENTLOAD_SEGMENT').collect{it.segmentID}[0]
hours=s.out('SEGMENTLOAD_SEGMENT').collect{it.lengthInHours}[0]
finalResult.add([tick, s.baseLoad*growthfactor, market, segmentID, hours])
}
return finalResult",

"LocationConstructionAtTick", "Location", "powerplant2 = v.in('SITELOCATION').filter{(it.constructionStartTime == tick)} 
pp2 = 0; 
for (pp in powerplant2){pp2 += 1;} 
[v.name, pp2]",

"TABLE_InitialPowerPlants", "DecarbonizationModel", "if(tick<1){
powerPlants=g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']];
finalResult = [];
columnNames=['Name', 'Technology', 'Location', 'Age', 'Owner', 'Capacity', 'Efficiency']
finalResult.add(columnNames)
for(p in powerPlants){
name = p.name
technology = p.out('TECHNOLOGY').collect{it.name}[0]
location = p.out('LOCATION').collect{it.name}[0]
age = -p.constructionStartTime-p.actualLeadtime-p.actualPermittime
owner = p.out('POWERPLANT_OWNER').collect{it.name}[0]
capacity = p.actualNominalCapacity
efficiency = p.actualEfficiency
finalResult.add([name,technology,location,age,owner,capacity,efficiency])
}
return finalResult
}",

